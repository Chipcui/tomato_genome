#!/usr/bin/env perl
use strict;
use warnings;
use English;
use Carp;  $SIG{__DIE__} = \&Carp::confess;
use Data::Dumper;
use FindBin;
use Getopt::Std;
use POSIX;

use File::Spec;
use File::Path qw/ rmtree /;
use File::Temp qw/tempfile/;
use List::Util qw/ sum min max /;
use List::MoreUtils qw/ uniq any /;

use Bio::Index::Fasta;

use CXGN::DB::Connection;

use CXGN::TomatoGenome::BACPublish qw/aggregate_filename agp_file/;
use CXGN::Publish qw/published_as publish/;

use CXGN::Cluster;
use CXGN::Cview::MapFactory;

use CXGN::Tools::Run;
use CXGN::Tools::Script qw/lock_script unlock_script/;

use CXGN::Genomic::CloneIdentifiers qw/parse_clone_ident assemble_clone_ident/;

use CXGN::TomatoGenome::Config;

########### CONFIGURATION/DEFAULTS ################

my $cfg = CXGN::TomatoGenome::Config->load_locked;
my $country_uploads_path = $cfg->{'country_uploads_path'};
my $publish_path = File::Spec->catdir(@{$cfg}{  'ftpsite_root',  'bac_publish_subdir' });
my $agp_path     = File::Spec->catdir(@{$cfg}{  'ftpsite_root',  'agp_publish_subdir' });

#mummer params
my $mummer_min_overlap = 1500;

my $cview_physical_map_version = 'p9';

###################################################

sub usage {
  my $message = shift || '';
  $message = "Error: $message\n" if $message;
  die <<EOU;
$message
Usage:
  $FindBin::Script [options]

  Takes the BAC sequences on each chromosome, tries to assemble them
  with mummer, and constructs an AGP file from the results.

  Options:

    -C run mummer jobs on the cluster, not locally.
       WARNING: mummer currently just segfaults when run on cluster
       nodes

    -p <dir>
       set BAC publishing dir to read sequences from.
       Default: $publish_path

    -a <dir>
       set directory for outputting AGP files
       Default: $agp_path

    -l <overlap>
       set the minimum overlap to use with mummer
       Default: $mummer_min_overlap

    -m <map id>
       the Cview map ID to use for establishing the positions of BACs
       Default: $cview_physical_map_version

    -c <list>
       list of chromosome numbers to process.  Default 0..12

    -A <dir>
       if passed, will save assembly files for each non-singleton
       AGP component in <dir>/<chr>.<index>/ where <chr> is the
       chromosome number and <index> is a sequential index number
       (with the count including singletons)

EOU
}
sub HELP_MESSAGE {usage()}

our %opt;
getopts('Cp:a:m:c:A:',\%opt) or usage();
@ARGV and usage(); #< there should be no non-option arguments

#get our publishing path
$publish_path = $opt{p} if defined $opt{p};
-r $publish_path or die "publish path $publish_path not found or not readable\n";

#get our AGP path
$agp_path = $opt{a} if defined $opt{a};
-w $agp_path or die "agp path $agp_path not found or not writable\n";

#get our mummer min overlap
$mummer_min_overlap = $opt{l} if defined $opt{l};
$mummer_min_overlap =~ /^\d+$/ && $mummer_min_overlap > 0
  or die "invalid -l min overlap '$mummer_min_overlap', must be a positive integer\n";

#get our chromosome numbers
my @chromosome_nums = (0..12);
@chromosome_nums = eval "($opt{c})" if defined $opt{c};
die "invalid chromosome numbers expression\n" if $EVAL_ERROR;

#get our cview physical map version
$cview_physical_map_version = $opt{m} if $opt{m};

# init the map data model
my $dbh = CXGN::DB::Connection->new({ config => $cfg });
my $mf =  CXGN::Cview::MapFactory->new( $dbh, $cfg );
my $physical_map = $mf->create( { map_version_id => $cview_physical_map_version } )
    or die "failed to create physical map object for map version $cview_physical_map_version\n";

lock_script() or die "Do not run more than one $FindBin::Script at the same time.\n";

my %chrdata; #< big hash of all the data about a given chromosome

#we will generate files for the chromosomes that don't have a manually uploaded one
my @chromosomes_to_generate = grep {
  if( my $agp = agp_file($_,0,$agp_path) ) {
    #is the file there autogenerated?  if so, regenerate, if not, leave it alone
    `grep autogenerated-by $agp` ? 'generate' : ''
  } else {
    #< no file at all
    'generate'
  }
} @chromosome_nums;
#warn  "regenerate agp files for chromosomes ".join(',',@chromosomes_to_generate).", please wait.\n";
#@chromosomes_to_generate = (5,10);

# find all the BAC sequences to use, and make per-chromosome sequence
# files to use as input to mummer
my $bacs_file = published_as( aggregate_filename("all_seqs",$publish_path) )
    or die "cannot find bacs file at ".aggregate_filename( 'all_seqs', $publish_path );
$bacs_file = Bio::SeqIO->new( -file => $bacs_file->{fullpath}, -format => 'fasta' );


for (@chromosomes_to_generate) {
    my ( $fh,$file ) = tempfile( UNLINK => 1 );
    $chrdata{$_} = { seqfile => $file, seqfile_fh => $fh,  chrnum => $_ };
}

while( my $seq = $bacs_file->next_seq ) {
    my $p = parse_clone_ident( $seq->id, 'versioned_bac_seq' )
        or die "could not parse seq id ".$seq->id;
    $p->{chr} = 0 if $p->{chr} eq 'unmapped';
    if( my $chr_rec = $chrdata{ $p->{chr} } ) {
        $chr_rec->{seqfile_fh}->print( ">", $seq->id, "\n", $seq->seq, "\n" );
    } else {
        #warn "skipping seq ".$seq->id." (chr $p->{chr})\n";
    }
}
$_->{seqfile_fh}->close for values %chrdata;

#dispatch mummer jobs for each of them
my $runfunc = do {
  if($opt{C}) {
    CXGN::Tools::Run->temp_base('/data/shared/tmp');
    'run_cluster'
  } else {
    'run'
  }
};
foreach my $chr_rec ( values %chrdata ) {
  chomp( my $cwd = `pwd` );
  chdir File::Spec->tmpdir;
  $chr_rec->{job} = CXGN::Tools::Run->$runfunc(qw( mummer -mum -b -n ),
					       -l => $mummer_min_overlap,
					       -F => $chr_rec->{seqfile},
					       $chr_rec->{seqfile},
					       { die_on_destroy => 1,
						 working_dir => File::Spec->tmpdir,
					       }
					      )
    or die "failed to run mummer on $chr_rec->{seqfile}!";
  chdir $cwd;
}
#when the script ends, clean up all the cluster job tempfiles
END { $_->{job} && $_->{job}->cleanup foreach values %chrdata }

#while the mummer jobs are running on the cluster, let's fetch all
#the known map positions of BACs.  to include a BAC cluster in our AGP, we
#have to know its location on the physical map
while( my ($chrnum,$chr_rec) = each %chrdata ) {

  next unless $chrnum > 0;

  #  warn "fetching chr for $chrnum\n";
  my $chr_map = $physical_map->get_chromosome($chrnum)
    or die "failed to fetch physical map chromosome $chrnum for map version $cview_physical_map_version\n";

  # make a hash of name => offset of mapped BACs on this chromosome
  my %b =
    map  { $_->get_marker_name => $_->get_offset }
    grep $_->isa('CXGN::Cview::Marker::Physical'),
    $chr_map->get_markers;

  $chr_rec->{mapped_bacs} = \%b;
}

# this construction will process the output of each job as it finishes,
# without necessarily waiting for the other jobs to finish
do {
  foreach my $rec (values %chrdata) {
    unless($rec->{job}->alive) {
      my $cluster_set  = mummer_to_clusterset( $rec->{job}->out_file );
      my @clusters      = map_clusters( $cluster_set, $rec->{mapped_bacs} );
      #warn "got ".scalar(@clusters)." mapped clusters\n";
      $rec->{agp_file} = generate_agp_file( $rec->{chrnum}, \@clusters );
    }
  }
} while( any { $_->{job}->alive } values %chrdata );

#now publish all the agp files we've generated
my @agp_publish_cmds = map {
  -f $_->{agp_file} or warn "$_->{agp_file} is not where I left it!\n";
  ['cp',$_->{agp_file},agp_file($_->{chrnum},1,$agp_path)]
} values %chrdata;

#print "publish commands: ".Dumper \@agp_publish_cmds;

publish(@agp_publish_cmds);

unlock_script();

$dbh->disconnect(42);

# system 'cat', map $_->{agp_file},values %chrdata;
# system 'validate_agp.pl', $_->{agp_file} foreach values %chrdata;

################ SUBROUTINES ##########################################################33

sub generate_agp_file {
  my ($chrnum, $contigs) = @_;
#   $Data::Dumper::Maxdepth = 5;
#   warn Dumper $contigs;

  my ($agp_fh,$agp_file) = tempfile(UNLINK => 1);
  print $agp_fh "#Draft Tomato chromosome $chrnum\n";
  print $agp_fh "#autogenerated-by SGN mummer/phrap AGP generator ($FindBin::Script)\n";

  my $seqs_index = Bio::Index::Fasta->new( -filename => do { my (undef,$tf) = tempfile(UNLINK => 1); $tf },
					   -write_flag => 1
					    );
  $seqs_index->make_index($chrdata{$chrnum}{seqfile});

  # we assume that 1cM is on average about 750kB of sequence (Wing, Zhang, and Tanksley, 1994).
  #
  my $correspondence = 100_000;
#  warn "Writing agp information to $agp_file...\n";

  my $line_count = 0;
  my $previous_global_end = 0; #< the global end of the previous line
  my $printline = sub(@) {
    my ($s,$e,@other) = @_;
    push @other,'' unless @other == 5;
    ++$line_count;
    #warn join("\t", 'S.lycopersicum-chr'.$chrnum,$s,$e,$line_count,@other)."\n";
    print $agp_fh join("\t", 'S.lycopersicum-chr'.$chrnum, $s, $e, $line_count, @other )."\n";
  };
  my $printed_unmapped_divider = 0; #<flag of whether we have printed the comment about unmapped sequences already
  my $contig_number = 0;
  for( my $precluster_number = 1; $precluster_number <= @$contigs; $precluster_number++ ) {
    my $mapped_contig = $contigs->[$precluster_number-1];
    my $offset = $mapped_contig->{offset};
    if( ! $printed_unmapped_divider && $offset > 500 ) {
      print $agp_fh "# END OF DRAFT CHROMOSOME BUILD.  THE LINES BELOW CONTAIN SEQUENCES THAT COULD NOT BE LOCATED ON THE PHYSICAL MAP\n";
      $printed_unmapped_divider = 1;
    }
    my $cluster = $mapped_contig->{cluster};
    #warn "new cluster: ".join(' ',$cluster->get_members)."\n";
    my $base = sprintf('%0.0f',$offset * $correspondence + 1);
    if( $base <= $previous_global_end+50_001 ) {
      #this means the BACs are mapped right on top of eachother, but they don't have any sequence overlap, so introduce a 'contig no' gap
      $base = $previous_global_end+50_001;
    }
#     if ($mapped_clusters{$cluster_positions{$offset}->get_unique_key()} > 1) { 
#       # determine order of bacs in the contig... TBD
#     }

    #put in an inter-contig gap if necessary
    if($base > $previous_global_end+1) {
      my $gap_start = $previous_global_end+1;
      my $gap_length = $base-$gap_start;
      my $gap_end = $gap_start+$gap_length-1;
      $printline->($gap_start,$gap_end,'N',$gap_length,'contig','no');
      $previous_global_end = $gap_end;
    } elsif( $base < $previous_global_end+1 ) {
      #or adjust the base up if necessary
      $base = $previous_global_end+1;
    }

    if( $opt{A} ) {
        my $dir = File::Spec->catdir( $opt{A}, "chr${chrnum}_precluster${precluster_number}" );
        rmtree($dir);
        $cluster->set_assembly_dir( $dir );
    }


    my $contigs_in_precluster = 0;
    foreach my $contig (  $cluster->get_consensus_base_segments( $seqs_index, simplification_passes => 2, simplification_window => 50 ) ) {
      my $previous_contig_end = 0; #< the contig end of the previous line
      ++$contig_number;

      #put in a 20kb clone gap if necessary, if we have members in a
      #cluster that did not assemble into one contig
      if( ++$contigs_in_precluster > 1 ) {
	my $gap_start = max($base,$previous_global_end+1);
	my $gap_end = $gap_start + 50_000 - 1;
	$printline->( $gap_start, $gap_end, 'N', 50_000, 'clone', 'yes' );
	$base = $gap_end + 1;
	$previous_global_end = $gap_end;
      }

      foreach my $member ( @$contig ) {
          my ( $member_contig_start, $member_contig_end, $name, $member_local_start, $member_local_end, $member_reverse ) = @$member;

          my $seq = $seqs_index->fetch($name)
              or die "could not get seq for '$name'";
          my $seqlength = $seq->length
              or die "no seq length returned for '$name' seq";

          # AGP has a slightly different meaning for components being
          # reversed.  the member coordinates are relative to the
          # *uncomplimented* sequence
          if( $member_reverse ) {
              ( $member_local_start, $member_local_end ) =
                   ( $seqlength - $member_local_end   + 1, $seqlength - $member_local_start + 1 );
          }

          my $member_global_start = $base + $member_contig_start - 1;
          my $member_global_end   = $base + $member_contig_end   - 1;

          # sometimes phrap shortens or lengthens runs of repetitive
          # nucleotides in order to build better consensus sequences.
          # this is usually only a few nt per 100kb.  these edits are
          # very difficult to represent in an AGP, so for now, just
          # ignore edits, fixing up coordinates if they go beyond the
          # end of the sequence.
          #
          # this inability to represent the phrap sequence edits is
          # going to lower the quality of some contigs
          if( $member_local_end > $seqlength ) {
              my $difference = $member_local_end - $seqlength;
              warn "WARNING: artificially shortening consensus segment $name ( $member_local_start, $member_local_end ) by $difference bases to cope with phrap sequence edit. This will make a slight error in chr $chrnum contig $contig_number (precluster $precluster_number).\n";
              $member_local_end -= $difference;
              unless( $member_reverse ) {
                  $member_global_end -= $difference;
              }
          }
          elsif( $member_local_start < 1 ) {
              my $difference = 1 - $member_local_start;
              warn "WARNING: artificially shortening consensus segment $name ( $member_local_start, $member_local_end ) by $difference bases to cope with phrap sequence edit. This will make a slight error in chr $chrnum contig $contig_number (precluster $precluster_number).\n";
              $member_local_start += $difference;
              if( $member_reverse ) {
                  $member_global_end  -= $difference;
              }
          }

          $printline->( $member_global_start, $member_global_end, 'F',
                        $name, $member_local_start, $member_local_end,
                        $member_reverse ? '-' : '+',
                       );
          $previous_global_end = $member_global_end;
          $previous_contig_end = $member_contig_end;
      }
    }
  }
  close $agp_fh; #< gotta close it to flush the buffers
  return $agp_file;
}


#$cluster_set is a CXGN::Cluster::ClusterSet
#$map_positions is a hashref of { bac_name => offset }
#returns a list of { cluster => obj, position => num }
#sorted ascending by position
sub map_clusters {
  my ($cluster_set,$map_positions) = @_;

  return
    sort {$a->{offset} <=> $b->{offset}}
    map {
      my $cluster = $_;
      #      warn "in cluster with ".join(' ',$cluster->get_members)."\n";
      #if the cluster has a map position, then we'll use it in the AGP
      if (my @map_positions = map { #warn "  $_ => ".$map_positions->{seqname_to_bacname($_)}."\n";
				    $map_positions->{seqname_to_bacname($_)} || ()
				  } $cluster->get_members
	 ) {
	my $avg_position = sum(@map_positions)/@map_positions;
	{ cluster => $cluster, offset => $avg_position, }
      } else {
	#put unmapped clusters way at the end of the chromosome
	{ cluster => $cluster, offset => 600 }
      }
    } $cluster_set->get_clusters;
}

#takes a versioned bac sequence identifier, changes it into a bac name
sub seqname_to_bacname($) {
  assemble_clone_ident('agi_bac_with_chrom',
		       parse_clone_ident(shift,
					 'versioned_bac_seq'
					)
		      )
}

#given a mummer output file, build a CXGN::Cluster::ClusterSet out of
#it
sub mummer_to_clusterset {
  my ($mummer_output_file) = @_;

  #here's the cluster set we're building
  my $cluster_set = CXGN::Cluster::ClusterSet->new;
  #  $cluster_set->set_debug(1);

  open (my $f, $mummer_output_file)
    or die "Can't open file $mummer_output_file for reading...";

  my $query = "";
  my $reverse;
  while (<$f>) {
    #print "MUMMER: $_\n";
    chomp;

    if (/^>/) {
      (undef,$query,$reverse) = split;
    } else {
      my ($subject, $query_start, $subject_start, $length) = split;

      $cluster_set->add_match( $query,
			       $subject,
			     );

    }
  }

  return $cluster_set;
}


# our %seqlens;
# sub sequence_length {
#   my ($sequence_name) = @_;
#   warn "$sequence_name has length $seqlens{$sequence_name}\n";
#   return $seqlens{$sequence_name};
# }
# sub index_sequence_lengths {
#   my ($seqfile) = @_;
#   open my $s,$seqfile or die "$! opening $seqfile";
#   my $i;
#   while(<$s>) {
#     if(s/^>//) {
#       ($i) = split;
#     } else {
#       $seqlens{$i} += length($_) - 1;
#     }
#   }
# }
