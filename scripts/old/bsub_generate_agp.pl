#!/usr/bin/env perl
use strict;
use warnings;
use English;
use Carp;
use FindBin;
use Getopt::Std;

use Data::Dumper;
use POSIX;

use File::Temp qw/tempfile/;
use List::Util qw/sum/;

use Bio::Index::Fasta;

use CXGN::DB::Connection;

use CXGN::TomatoGenome::BACPublish qw/aggregate_filename agp_file/;
use CXGN::Publish qw/published_as publish/;

use CXGN::Cluster;
use CXGN::Cview::MapFactory;

use CXGN::Tools::List qw/any max/;
use CXGN::Tools::Run;
use CXGN::Tools::Script qw/lock_script unlock_script/;

use CXGN::Genomic::CloneIdentifiers qw/parse_clone_ident assemble_clone_ident/;

use CXGN::TomatoGenome::Config;

########### CONFIGURATION/DEFAULTS ################

my $cfg = CXGN::TomatoGenome::Config->load_locked;
my $country_uploads_path = $cfg->{'country_uploads_path'};
my $publish_path = File::Spec->catdir(@{$cfg}{  'ftpsite_root',  'bac_publish_subdir' });
my $agp_path     = File::Spec->catdir(@{$cfg}{  'ftpsite_root',  'agp_publish_subdir' });

#mummer params
my $mummer_min_overlap = 1500;

my $cview_physical_map_version = 'p9';

###################################################

sub usage {
  my $message = shift || '';
  $message = "Error: $message\n" if $message;
  die <<EOU;
$message
Usage:
  $FindBin::Script [options]

  Takes the BAC sequences on each chromosome, tries to assemble them
  with mummer, and constructs an AGP file from the results.

  Options:

    -C run mummer jobs on the cluster, not locally.
       WARNING: mummer currently just segfaults when run on cluster
       nodes

    -p <dir>
       set BAC publishing dir to read sequences from.
       Default: $publish_path

    -a <dir>
       set directory for outputting AGP files
       Default: $agp_path

    -l <overlap>
       set the minimum overlap to use with mummer
       Default: $mummer_min_overlap

    -m <map id>
       the Cview map ID to use for establishing the positions of BACs
       Default: $cview_physical_map_version

    -c <list>
       list of chromosome numbers to process.  Default 0..12

EOU
}
sub HELP_MESSAGE {usage()}

our %opt;
getopts('Cp:a:m:c:',\%opt) or usage();
@ARGV and usage(); #< there should be no non-option arguments

#get our publishing path
$publish_path = $opt{p} if defined $opt{p};
-r $publish_path or die "publish path $publish_path not found or not readable\n";

#get our AGP path
$agp_path = $opt{a} if defined $opt{a};
-w $agp_path or die "agp path $agp_path not found or not writable\n";

#get our mummer min overlap
$mummer_min_overlap = $opt{l} if defined $opt{l};
$mummer_min_overlap =~ /^\d+$/ && $mummer_min_overlap > 0
  or die "invalid -l min overlap '$mummer_min_overlap', must be a positive integer\n";

#get our chromosome numbers
my @chromosome_nums = (0..12);
@chromosome_nums = eval "($opt{c})" if defined $opt{c};
die "invalid chromosome numbers expression\n" if $EVAL_ERROR;

#get our cview physical map version
$cview_physical_map_version = $opt{m} if $opt{m};

lock_script() or die "Do not run more than one $FindBin::Script at the same time.\n";

my %chrdata; #< big hash of all the data about a given chromosome

#we will generate files for the chromosomes that don't have a manually uploaded one
my @chromosomes_to_generate = grep {
  if( my $agp = agp_file($_,0,$agp_path) ) {
    #is the file there autogenerated?  if so, regenerate, if not, leave it alone
    `grep autogenerated-by $agp` ? 'generate' : ''
  } else {
    #< no file at all
    'generate'
  }
} @chromosome_nums;
#warn  "regenerate agp files for chromosomes ".join(',',@chromosomes_to_generate).", please wait.\n";
#@chromosomes_to_generate = (5,10);

#find all the BAC sequences to use, each chromosome has a published
#fasta file of all its sequences
foreach my $chr (@chromosomes_to_generate) {
  my $seqsfile = aggregate_filename("chr${chr}_finished_seqs",$publish_path);
  unless(-r $seqsfile) {
    $seqsfile = published_as($seqsfile);
    $seqsfile &&= $seqsfile->{fullpath};
  }
  $seqsfile ||= '';
  -r $seqsfile or die "chromosome $chr sequences file '$seqsfile' not found or not readable\n";
#  index_sequence_lengths($seqsfile);
  $chrdata{$chr} = {seqfile => $seqsfile, chrnum => $chr };
}

#dispatch mummer jobs for each of them
my $runfunc = do {
  if($opt{C}) {
    CXGN::Tools::Run->temp_base('/data/shared/tmp');
    'run_cluster'
  } else {
    'run'
  }
};
foreach my $chr_rec ( values %chrdata ) {
  chomp( my $cwd = `pwd` );
  chdir File::Spec->tmpdir;
  $chr_rec->{job} = CXGN::Tools::Run->$runfunc(qw( mummer -mum -b -n ),
					       -l => $mummer_min_overlap,
					       -F => $chr_rec->{seqfile},
					       $chr_rec->{seqfile},
					       { die_on_destroy => 1,
						 working_dir => File::Spec->tmpdir,
					       }
					      )
    or die "failed to run mummer on $chr_rec->{seqfile}!";
  chdir $cwd;
}
#when the script ends, clean up all the cluster job tempfiles
END { $_->{job} && $_->{job}->cleanup foreach values %chrdata }

#while the mummer jobs are running on the cluster, let's fetch all
#the known map positions of BACs.  to include a BAC cluster in our AGP, we
#have to know its location on the physical map
my $dbh = CXGN::DB::Connection->new({ config => $cfg });
my $mf =  CXGN::Cview::MapFactory->new( $dbh, $cfg );
my $physical_map = $mf->create( { map_version_id => $cview_physical_map_version } )
    or die "failed to create physical map object for map version $cview_physical_map_version\n";
while( my ($chrnum,$chr_rec) = each %chrdata ) {

  next unless $chrnum > 0;

  #  warn "fetching chr for $chrnum\n";
  my $chr_map = $physical_map->get_chromosome($chrnum)
    or die "failed to fetch physical map chromosome $chrnum for map version $cview_physical_map_version\n";

  # make a hash of name => offset of mapped BACs on this chromosome
  my %b =
    map  { $_->get_marker_name => $_->get_offset }
    grep $_->isa('CXGN::Cview::Marker::Physical'),
    $chr_map->get_markers;

  $chr_rec->{mapped_bacs} = \%b;
}

# this construction will process the output of each job as it finishes,
# without necessarily waiting for the other jobs to finish
do {
  foreach my $rec (values %chrdata) {
    unless($rec->{job}->alive) {
      my $cluster_set  = mummer_to_clusterset( $rec->{job}->out_file );
      my @clusters      = map_clusters( $cluster_set, $rec->{mapped_bacs} );
      #warn "got ".scalar(@clusters)." mapped clusters\n";
      $rec->{agp_file} = generate_agp_file( $rec->{chrnum}, \@clusters );
    }
  }
} while( any map $_->{job}->alive, values %chrdata );

#now publish all the agp files we've generated
my @agp_publish_cmds = map {
  -f $_->{agp_file} or warn "$_->{agp_file} is not where I left it!\n";
  ['cp',$_->{agp_file},agp_file($_->{chrnum},1,$agp_path)]
} values %chrdata;

#print "publish commands: ".Dumper \@agp_publish_cmds;

publish(@agp_publish_cmds);

unlock_script();

# system 'cat', map $_->{agp_file},values %chrdata;
# system 'validate_agp.pl', $_->{agp_file} foreach values %chrdata;

################ SUBROUTINES ##########################################################33

sub generate_agp_file {
  my ($chrnum, $contigs) = @_;
#   $Data::Dumper::Maxdepth = 5;
#   warn Dumper $contigs;

  my ($agp_fh,$agp_file) = tempfile(UNLINK => 1);
  print $agp_fh "#Draft Tomato chromosome $chrnum\n";
  print $agp_fh "#autogenerated-by SGN mummer/phrap AGP generator ($FindBin::Script)\n";

  my $seqs_index = Bio::Index::Fasta->new( -filename => do { my (undef,$tf) = tempfile(UNLINK => 1); $tf },
					   -write_flag => 1
					    );
  $seqs_index->make_index($chrdata{$chrnum}{seqfile});

  # we assume that 1cM is on average about 750kB of sequence (Wing, Zhang, and Tanksley, 1994).
  #
  my $correspondence = 100_000;
#  warn "Writing agp information to $agp_file...\n";

  our $line_count = 0;
  my $previous_global_end = 0; #< the global end of the previous line
  my $printline = sub(@) {
    my ($s,$e,@other) = @_;
    push @other,'' unless @other == 5;
    ++$line_count;
    #warn join("\t", 'S.lycopersicum-chr'.$chrnum,$s,$e,$line_count,@other)."\n";
    print $agp_fh join("\t", 'S.lycopersicum-chr'.$chrnum,$s,$e,$line_count,@other)."\n";
  };
  my $printed_unmapped_divider = 0; #<flag of whether we have printed the comment about unmapped sequences already
  foreach my $mapped_contig (@$contigs) {
    my $offset = $mapped_contig->{offset};
    if( ! $printed_unmapped_divider && $offset > 500 ) {
      print $agp_fh "# END OF DRAFT CHROMOSOME BUILD.  THE LINES BELOW CONTAIN SEQUENCES THAT COULD NOT BE LOCATED ON THE PHYSICAL MAP\n";
      $printed_unmapped_divider = 1;
    }
    my $cluster = $mapped_contig->{cluster};
    #warn "new cluster: ".join(' ',$cluster->get_members)."\n";
    my $base = sprintf('%0.0f',$offset * $correspondence + 1);
    if( $base <= $previous_global_end+50_001 ) {
      #this means the BACs are mapped right on top of eachother, but they don't have any sequence overlap, so introduce a 'contig no' gap
      $base = $previous_global_end+50_001;
    }
#     if ($mapped_clusters{$cluster_positions{$offset}->get_unique_key()} > 1) { 
#       # determine order of bacs in the contig... TBD
#     }

    #put in an inter-contig gap if necessary
    if($base > $previous_global_end+1) {
      my $gap_start = $previous_global_end+1;
      my $gap_length = $base-$gap_start;
      my $gap_end = $gap_start+$gap_length-1;
      $printline->($gap_start,$gap_end,'N',$gap_length,'contig','no');
      $previous_global_end = $gap_end;
    } elsif( $base < $previous_global_end+1 ) {
      #or adjust the base up if necessary
      $base = $previous_global_end+1;
    }

    my $contig_count = 0;
    foreach my $contig ($cluster->get_contig_coords($seqs_index)) {
      my $previous_contig_end = 0; #< the contig end of the previous line

      #put in a 20kb clone gap if necessary, if we have members in a
      #cluster that did not assemble into one contig
      if( ++$contig_count > 1 ) {
	my $gap_start = max($base,$previous_global_end+1);
	my $gap_end = $gap_start + 50_000 - 1;
	$printline->( $gap_start, $gap_end, 'N', 50_000, 'clone', 'yes' );
	$base = $gap_end + 1;
	$previous_global_end = $gap_end;
      }

      foreach my $member (@$contig) {
	my ($name, $member_contig_start, $member_contig_end, $strand) = @$member;
	#warn "processing member '$name'...\n";
	my $seq = $seqs_index->fetch($name)
	  or die "could not get seq for '$name'";
	my $seqlength = $seq->length
	  or die "no seq length returned for '$name' seq";

	my $member_length = $member_contig_end-$member_contig_start+1;

	# sometimes phrap shortens or lengthens runs of repetitive
	# nucleotides in order to build better consensus sequences.
	# this is usually only a few nt per 100kb, so for the sake of
	# building an AGP, just undo it and ignore it
	unless( $member_length == $seqlength ) {
	  $member_contig_end = $member_contig_start+$seqlength-1;
	  $member_length = $seqlength;
	}
	die "invalid member length $member_length for $name ($seqlength bases)"
	  unless $member_length == $seqlength;

	#warn join(' ',@$member)."\n";

	my $overlap_with_previous_member = $previous_contig_end - $member_contig_start + 1;

	my $member_local_end   = $member_contig_end-$member_contig_start + 1;
	my $member_local_start = 1+$overlap_with_previous_member;

	# if it is completely contained in another member, just skip it
	next if $member_local_start > $member_local_end;

	$member_contig_start  += $overlap_with_previous_member;

	my $member_global_start = $base + $member_contig_start - 1;
	my $member_global_end   = $base + $member_contig_end   - 1;
	my $reverse = $strand == -1;

# 	if( $member_global_start < $previous_global_end+1) {
# 	  my $difference = $previous_global_end + 1 - $member_global_start;
# 	  $member_global_start += $difference;
# 	  $member_global_end   += $difference;
# 	}
	
	$printline->( $member_global_start, $member_global_end, 'F',
		      $name, $member_local_start, $member_local_end,
		      $reverse ? '-' : '+',
		    );
	$previous_global_end = $member_global_end;
	$previous_contig_end = $member_contig_end;
      }
    }
  }
  close $agp_fh; #< gotta close it to flush the buffers
  return $agp_file;
}


#$cluster_set is a CXGN::Cluster::ClusterSet
#$map_positions is a hashref of { bac_name => offset }
#returns a list of { cluster => obj, position => num }
#sorted ascending by position
sub map_clusters {
  my ($cluster_set,$map_positions) = @_;

  return
    sort {$a->{offset} <=> $b->{offset}}
    map {
      my $cluster = $_;
      #      warn "in cluster with ".join(' ',$cluster->get_members)."\n";
      #if the cluster has a map position, then we'll use it in the AGP
      if (my @map_positions = map { #warn "  $_ => ".$map_positions->{seqname_to_bacname($_)}."\n";
				    $map_positions->{seqname_to_bacname($_)} || ()
				  } $cluster->get_members
	 ) {
	my $avg_position = sum(@map_positions)/@map_positions;
	{ cluster => $cluster, offset => $avg_position, }
      } else {
	#put unmapped clusters way at the end of the chromosome
	{ cluster => $cluster, offset => 600 }
      }
    } $cluster_set->get_clusters;
}

#takes a versioned bac sequence identifier, changes it into a bac name
sub seqname_to_bacname($) {
  assemble_clone_ident('agi_bac_with_chrom',
		       parse_clone_ident(shift,
					 'versioned_bac_seq'
					)
		      )
}

#given a mummer output file, build a CXGN::Cluster::ClusterSet out of
#it
sub mummer_to_clusterset {
  my ($mummer_output_file) = @_;

  #here's the cluster set we're building
  my $cluster_set = CXGN::Cluster::ClusterSet->new;
  #  $cluster_set->set_debug(1);

  open (my $f, $mummer_output_file)
    or die "Can't open file $mummer_output_file for reading...";

  my $query = "";
  my $reverse;
  while (<$f>) {
    #print "MUMMER: $_\n";
    chomp;

    if (/^>/) {
      (undef,$query,$reverse) = split;
    } else {
      my ($subject, $query_start, $subject_start, $length) = split;

      $cluster_set->add_match( $query,
			       $subject,
			     );

    }
  }

  return $cluster_set;
}

# our %seqlens;
# sub sequence_length {
#   my ($sequence_name) = @_;
#   warn "$sequence_name has length $seqlens{$sequence_name}\n";
#   return $seqlens{$sequence_name};
# }
# sub index_sequence_lengths {
#   my ($seqfile) = @_;
#   open my $s,$seqfile or die "$! opening $seqfile";
#   my $i;
#   while(<$s>) {
#     if(s/^>//) {
#       ($i) = split;
#     } else {
#       $seqlens{$i} += length($_) - 1;
#     }
#   }
# }
